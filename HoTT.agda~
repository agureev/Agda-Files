{-# OPTIONS --without-K #-} 
 

open import Agda.Primitive public using (Level; lzero; lsuc; _âŠ”_; SetÏ‰) 


data â„• : Set where
  zero : â„• 
  succ : â„• â†’ â„•


â„•-induction : âˆ€ {C : â„• â†’ Set} â†’ (C (zero)) â†’ (âˆ€ (n : â„•) â†’ (C n â†’ (C (succ n)))) â†’ (âˆ€ (n : â„•) â†’ C n)
â„•-induction p f zero = p 
â„•-induction p f (succ n) = f n (â„•-induction p f n) 

data Bool : Set where
  true : Bool
  false : Bool

Bool-induction : âˆ€ {C : Bool â†’ Set} â†’ (C true) â†’ (C false) â†’ (âˆ€ (c : Bool) â†’ C c)
Bool-induction p q true = p
Bool-induction p q false = q

data Empty : Set where

Empty-induction : âˆ€ {C : Empty â†’ Set} â†’ (âˆ€ (x : Empty) â†’ C x)
Empty-induction ()

data ğŸ™ : Set where
  pt : ğŸ™

ğŸ™-induction : âˆ€ {C : ğŸ™ â†’ Set} â†’ (C pt) â†’ (âˆ€ (x : ğŸ™) â†’ C x)
ğŸ™-induction H pt = H

data _+_ {â„“1 â„“2}(A : Set â„“1) (B : Set â„“2) : Set (â„“1 âŠ” â„“2) where

    inl : A â†’ A + B
    inr : B â†’ A + B

rec+ : âˆ€  {A : Set} {B : Set } {C : Set } â†’
    (A â†’ C) â†’ (B â†’ C) â†’ (A + B â†’ C)
rec+ f g (inl x) = f x
rec+ f g (inr x) = g x



ind+ : âˆ€  {A : Set } {B : Set } {C : A + B â†’ Set } â†’ 
        ( âˆ€ (a : A) â†’ C (inl a)) â†’ ( âˆ€ (b : B) â†’ (C (inr b)) ) â†’ ( âˆ€ (c : A + B) â†’ (C c))
ind+ f g (inl x) = f x
ind+ f g (inr x) = g x


data _Ã—_ (A : Set) (B : Set) : Set where
  pair : A â†’ B â†’ A Ã— B

recÃ— : âˆ€ {A : Set} {B : Set} {C : Set} â†’ 
   (A â†’ B â†’ C) â†’ (A Ã— B â†’ C)
recÃ— f (pair x xâ‚) = f x xâ‚

indÃ— : âˆ€ {A : Set} {B : Set} {C : A Ã— B â†’ Set} â†’ 
  (âˆ€ (a : A) â†’ âˆ€ (b : B) â†’ C(pair a b)) â†’ (âˆ€ (x : A Ã— B) â†’ C(x))
indÃ— f (pair x xâ‚) = f x xâ‚

data Î£ (A : Set) (B : A â†’ Set) : Set where
  deppair : âˆ€ (x : A) â†’ B x â†’ Î£ A B

Î£-recursion : âˆ€ {A : Set} {B : A â†’ Set} {C : Set} â†’ 
                                                 (âˆ€ (a : A) â†’ B a â†’ C) â†’ (Î£ A B â†’ C)
Î£-recursion f (deppair x xâ‚) = f x xâ‚


Î£-induction : âˆ€ {A : Set} {B : A â†’ Set} {C : (Î£ A B) â†’ Set} â†’ 
                                   (âˆ€ (a : A) â†’ âˆ€ (b : B a) â†’ (C (deppair a b))) â†’ (âˆ€ (x : Î£ A B) â†’ C x)
Î£-induction f (deppair x xâ‚) = f x xâ‚

data Con : Set
data Ty : Con â†’ Set 

data Con where
 âŠ¥ : Con
 _,_ : (Î“ : Con) â†’ Ty Î“ â†’ Con 

data Ty where 
 U : âˆ€ {Î“} â†’ Ty Î“
 Î  : âˆ€ {Î“} (A : Ty Î“) (B : Ty (Î“ , A)) â†’ Ty Î“



data _â‰¡_   {A : Set} : A â†’ A â†’ Set  where
  refl : âˆ€ (a : A) â†’  a â‰¡ a

Id-induction : âˆ€ {A : Set } {C : forall (x y : A) ->  (x â‰¡ y) -> Set } â†’ ( âˆ€ (x : A) â†’ (C x x (refl x)) ) â†’ (forall  ( a b : A)  (p : a â‰¡ b) â†’ (C a b p) )
Id-induction {A} {C} f a .a (refl .a) = f a

Id-recursion : âˆ€ {A : Set } {C : Set } â†’ ( âˆ€ (x : A) â†’ C ) â†’ (forall  ( a b : A)  (p : a â‰¡ b) â†’ C )
Id-recursion x a .a (refl .a) = x a

inv-path : âˆ€ {A : Set} {a b : A} (p : a â‰¡ b)  â†’  b â‰¡ a
inv-path (refl _) = refl _

concat : âˆ€  {A : Set} {x y z : A} â†’  x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
concat (refl _) q = q

add-â„• :  â„•  â†’  â„•  â†’  â„• 
add-â„• zero m = m
add-â„• (succ n) m = succ (add-â„• n m)

mult-â„• : â„• â†’ â„• â†’ â„•
mult-â„• zero m = zero
mult-â„• (succ n) m = add-â„• (mult-â„• n m) m

max-â„• : â„• â†’ â„• â†’ â„•
max-â„• zero m = m
max-â„• (succ n) zero = succ n
max-â„• (succ n) (succ m) = succ (max-â„• n m) 

min-â„• : â„• â†’ â„• â†’ â„•
min-â„• zero m = zero
min-â„• (succ n) zero = zero
min-â„• (succ n) (succ m) = succ (min-â„• n m)

pred : â„• â†’ â„•
pred zero = zero
pred (succ n) = n

Â¬_ : Set â†’ Set
Â¬ A = A â†’ Empty

neg-Bool : Bool â†’ Bool
neg-Bool true = false
neg-Bool false = true

_âˆ§_ : Bool â†’ Bool â†’ Bool
false âˆ§ b2 = false
true âˆ§ true = true
true âˆ§ false = false

_âˆ¨_ : Bool â†’ Bool â†’ Bool
true âˆ¨ b2 = true
false âˆ¨ true = true
false âˆ¨ false = false

_â†”_ : Set â†’ Set â†’ Set
A â†” B = (A â†’ B) Ã— (B â†’ A)

data list (A : Set) :  (Set)  where
  nil :  list A
  cons : A â†’ (list A) â†’ (list A)


fold-list : âˆ€ {A B : Set} â†’ B â†’  (A â†’ B â†’ B) â†’ (list A â†’ B)
fold-list b Î¼ nil = b
fold-list b Î¼ (cons x l) = Î¼ x (fold-list b Î¼ l)

map-list : âˆ€ {A B : Set} â†’ (A â†’ B) â†’ (list A â†’ list B)
map-list f nil = nil
map-list f (cons x l) = cons (f x) (map-list f l)

concat-list : âˆ€ {A : Set} â†’ list A â†’ list A â†’ list A
concat-list nil l2 = l2
concat-list (cons x l1) l2 = cons x (concat-list l1 l2)

flatten-list : âˆ€ {A : Set} â†’ list (list A) â†’ list A
flatten-list nil = nil
flatten-list (cons nil lâ‚) = flatten-list lâ‚
flatten-list (cons (cons x l) lâ‚) = cons x (flatten-list (cons l lâ‚))

_Â·_ : âˆ€ {A : Set}  {x y z : A} â†’  (y â‰¡ z) â†’ (x â‰¡ y) â†’ (x â‰¡ z)
p Â· q = concat q p

concat-assoc : âˆ€ {A : Set} {x y z w : A} (p : x â‰¡ y) (q : y â‰¡ z) (t : z â‰¡ w) â†’  ((t Â· (q Â· p)) â‰¡  ((t Â· q) Â· p))
concat-assoc (refl _) (refl _) t = refl t

refl-l : âˆ€ {A : Set} {x y  : A } (p : x  â‰¡ y) â†’  ((refl y) Â· p) â‰¡ p
refl-l (refl _) = refl _

refl-r : âˆ€ {A : Set} {x y : A} (p : x â‰¡ y) â†’ (p Â· (refl x)) â‰¡ p
refl-r p = refl p

left-inv : âˆ€ {A : Set} {x y : A} (p : x â‰¡ y) â†’ ((inv-path p) Â·  p) â‰¡ (refl _)
left-inv (refl _) = refl _

right-inv :  âˆ€ {A : Set} {x y : A} (p : x â‰¡ y) â†’ (p Â· (inv-path p)) â‰¡ (refl _)
right-inv (refl _) = refl _

fun-ap : âˆ€ {A B : Set} {x y : A} (f : A â†’ B) (p : x â‰¡ y) â†’ (f x) â‰¡ (f y)
fun-ap f (refl _) = refl _

_âˆ˜_ : âˆ€ {A B C : Set} â†’ (B â†’ C) â†’ (A â†’ B) â†’ (A â†’ C)
(g âˆ˜ f) x = g (f x)

id : âˆ€ (A : Set) â†’ A â†’ A
id A x = x

ap-id : âˆ€ {A : Set} {x y : A} (p : x â‰¡ y) â†’ p â‰¡ (fun-ap (id A ) p)
ap-id (refl x) = refl _

ap-comp : âˆ€ {A B C : Set} {x y : A} (p : x â‰¡ y) (f : A â†’ B) (g : B â†’ C) â†’ (fun-ap g (fun-ap f p)) â‰¡ (fun-ap (g âˆ˜ f) p)
ap-comp (refl x) f g = refl _


ap-refl : âˆ€ {A B : Set} {x y : A} (f : A
